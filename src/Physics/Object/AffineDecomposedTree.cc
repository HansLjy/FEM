#include "AffineDecomposedTree.h"
#include "unsupported/Eigen/KroneckerProduct"

void PTCGradient(const double in1[3], const double in2[3], double gradient[6]) {
  double b_gradient_tmp;
  double gradient_tmp;
  double t10;
  double t12;
  double t2;
  double t3;
  double t4;
  double t5;
  double t6;
  double t7;
  // PTCGradient
  //     GRADIENT = PTCGradient(IN1,IN2)
  //     This function was generated by the Symbolic Math Toolbox version 9.2.
  //     27-Jan-2023 12:44:38
  t2 = in2[0] * in2[0];
  t3 = in2[1] * in2[1];
  t4 = in2[2] * in2[2];
  t5 = in1[0] * in1[0];
  t6 = in1[1] * in1[1];
  t7 = in1[2] * in1[2];
  t10 = 1.0 / std::sqrt((t2 + t3) + t4);
  t12 = 1.0 / std::sqrt((t5 + t6) + t7);
  gradient_tmp = t10 * t12 * t12 * t12;
  gradient[0] =
      gradient_tmp * (((in2[0] * t6 + in2[0] * t7) - in1[0] * in2[1] * in1[1]) -
                      in1[0] * in2[2] * in1[2]);
  b_gradient_tmp = in2[0] * in1[0];
  gradient[1] =
      gradient_tmp * (((in2[1] * t5 + in2[1] * t7) - b_gradient_tmp * in1[1]) -
                      in1[1] * in2[2] * in1[2]);
  gradient[2] =
      gradient_tmp * (((in2[2] * t5 + in2[2] * t6) - b_gradient_tmp * in1[2]) -
                      in2[1] * in1[1] * in1[2]);
  gradient_tmp = in2[0] * in2[1];
  b_gradient_tmp = t10 * t10 * t10 * t12;
  t5 = in2[0] * in2[2];
  gradient[3] =
      b_gradient_tmp *
      (((in1[0] * t3 + in1[0] * t4) - gradient_tmp * in1[1]) - t5 * in1[2]);
  t6 = in2[1] * in2[2];
  gradient[4] =
      b_gradient_tmp *
      (((in1[1] * t2 + in1[1] * t4) - gradient_tmp * in1[0]) - t6 * in1[2]);
  gradient[5] = b_gradient_tmp *
                (((in1[2] * t2 + in1[2] * t3) - t5 * in1[0]) - t6 * in1[1]);
}

void PTCHessian(const double in1[3], const double in2[3], double hessian[36]) {
  double b_t20_tmp;
  double b_t24_tmp;
  double t10;
  double t12;
  double t127;
  double t127_tmp;
  double t128;
  double t128_tmp;
  double t129;
  double t130;
  double t131;
  double t132;
  double t139;
  double t14;
  double t140;
  double t145;
  double t146;
  double t147;
  double t15;
  double t16;
  double t17;
  double t18;
  double t19;
  double t2;
  double t20;
  double t20_tmp;
  double t24;
  double t24_tmp;
  double t28;
  double t32;
  double t33;
  double t34;
  double t4;
  double t41;
  double t42;
  double t43;
  double t43_tmp;
  double t53;
  double t57;
  double t6;
  double t61;
  double t8;
  double t80;
  double t81;
  double t94;
  double t96;
  double t97;
  double t99;
  // PTCHessian
  //     HESSIAN = PTCHessian(IN1,IN2)
  //     This function was generated by the Symbolic Math Toolbox version 9.2.
  //     27-Jan-2023 12:44:38
  t2 = in2[0] * in2[0];
  t4 = in2[1] * in2[1];
  t6 = in2[2] * in2[2];
  t8 = in1[0] * in1[0];
  t10 = in1[1] * in1[1];
  t12 = in1[2] * in1[2];
  t20_tmp = in2[0] * in2[1];
  b_t20_tmp = t20_tmp * in1[0];
  t20 = b_t20_tmp * in1[1];
  t24_tmp = in2[0] * in2[2];
  b_t24_tmp = t24_tmp * in1[0];
  t24 = b_t24_tmp * in1[2];
  t146 = in2[1] * in2[2];
  t28 = t146 * in1[1] * in1[2];
  t14 = in2[0] * in1[0] * in1[0] * in1[0];
  t15 = in1[0] * in2[0] * in2[0] * in2[0];
  t16 = in2[1] * in1[1] * in1[1] * in1[1];
  t17 = in1[1] * in2[1] * in2[1] * in2[1];
  t18 = in2[2] * in1[2] * in1[2] * in1[2];
  t19 = in1[2] * in2[2] * in2[2] * in2[2];
  t32 = t20_tmp * t12;
  t33 = t24_tmp * t10;
  t34 = t146 * t8;
  t145 = in1[1] * in1[2];
  t41 = t145 * t2;
  t147 = in1[0] * in1[2];
  t42 = t147 * t4;
  t43_tmp = in1[0] * in1[1];
  t43 = t43_tmp * t6;
  t53 = t2 * t8;
  t57 = t4 * t10;
  t61 = t6 * t12;
  t80 = (t2 + t4) + t6;
  t81 = (t8 + t10) + t12;
  t94 = 1.0 / std::sqrt(t80);
  t97 = 1.0 / std::sqrt(t81);
  t96 = t94 * t94 * t94 * t94 * t94;
  t99 = t97 * t97 * t97 * t97 * t97;;
  t127_tmp = t94 * t94 * t94 * t97 * t97 * t97;
  t127 = t127_tmp * ((((t20_tmp * t8 + t32) + t43_tmp * t4) + t43) -
                     t24_tmp * in1[1] * in1[2]);
  t128_tmp = t146 * in1[0];
  t128 = t127_tmp *
         ((((t20_tmp * t10 + t32) + t43_tmp * t2) + t43) - t128_tmp * in1[2]);
  t129 = t127_tmp * ((((t24_tmp * t8 + t33) + t42) + t147 * t6) -
                     t20_tmp * in1[1] * in1[2]);
  t130 = t127_tmp *
         ((((t33 + t24_tmp * t12) + t147 * t2) + t42) - t128_tmp * in1[1]);
  t131 = t127_tmp *
         ((((t34 + t146 * t10) + t41) + t145 * t6) - b_t20_tmp * in1[2]);
  t132 = t127_tmp *
         ((((t34 + t146 * t12) + t41) + t145 * t4) - b_t24_tmp * in1[1]);
  t139 = t127_tmp * (((((t24 + t28) + t53) + t2 * t10) + t4 * t8) + t57);
  t140 = t127_tmp * (((((t20 + t28) + t53) + t2 * t12) + t6 * t8) + t61);
  t20 = t127_tmp * (((((t20 + t24) + t57) + t4 * t12) + t6 * t10) + t61);
  t43 = in2[0] * in1[1];
  t33 = in1[0] * in2[1];
  t32 = t20_tmp * in2[2];
  t43_tmp = t96 * t97;
  t28 =
      t43_tmp *
      ((((t32 * in1[2] * 3.0 + t33 * t2 * 3.0) + t43 * t4 * 3.0) - t43 * t80) -
       t33 * t80);
  t24_tmp = in2[0] * in1[2];
  t147 = in1[0] * in2[2];
  t53 = t43_tmp *
        ((((t32 * in1[1] * 3.0 + t147 * t2 * 3.0) + t24_tmp * t6 * 3.0) -
          t24_tmp * t80) -
         t147 * t80);
  b_t20_tmp = in2[1] * in1[2];
  b_t24_tmp = in1[1] * in2[2];
  t41 = t43_tmp *
        ((((t32 * in1[0] * 3.0 + b_t24_tmp * t4 * 3.0) + b_t20_tmp * t6 * 3.0) -
          b_t20_tmp * t80) -
         b_t24_tmp * t80);
  t32 = t94 * t99;
  t145 = t32 *
         ((((t147 * in1[1] * in1[2] * 3.0 + t43 * t8 * 3.0) + t33 * t10 * 3.0) -
           t43 * t81) -
          t33 * t81);
  t146 = t32 * ((((t33 * in1[1] * in1[2] * 3.0 + t24_tmp * t8 * 3.0) +
                  t147 * t12 * 3.0) -
                 t24_tmp * t81) -
                t147 * t81);
  t34 = in2[0] * in1[0];
  t147 = t32 * ((((t34 * in1[1] * in1[2] * 3.0 + b_t20_tmp * t10 * 3.0) +
                  b_t24_tmp * t12 * 3.0) -
                 b_t20_tmp * t81) -
                b_t24_tmp * t81);
  t33 = in2[1] * in1[1];
  b_t20_tmp = in2[2] * in1[2];
  b_t24_tmp = t34 * t10;
  t42 = t33 * t8;
  t128_tmp = t34 * t12;
  t24_tmp = b_t20_tmp * t8;
  t43 = t33 * t12;
  t43_tmp = b_t20_tmp * t10;
  t32 = -t94 * t99;
  hessian[0] =
      t32 *
      (((((((t16 + t18) + b_t24_tmp * 3.0) - t42 * 2.0) + t128_tmp * 3.0) -
         t24_tmp * 2.0) +
        t43) +
       t43_tmp);
  hessian[1] = t145;
  hessian[2] = t146;
  hessian[3] = t20;
  hessian[4] = -t128;
  hessian[5] = -t130;
  hessian[6] = t145;
  hessian[7] =
      t32 *
      (((((((t14 + t18) - b_t24_tmp * 2.0) + t42 * 3.0) + t128_tmp) + t24_tmp) +
        t43 * 3.0) -
       t43_tmp * 2.0);
  hessian[8] = t147;
  hessian[9] = -t127;
  hessian[10] = t140;
  hessian[11] = -t132;
  hessian[12] = t146;
  hessian[13] = t147;
  hessian[14] =
      t32 *
      (((((((t14 + t16) + b_t24_tmp) + t42) - t128_tmp * 2.0) + t24_tmp * 3.0) -
        t43 * 2.0) +
       t43_tmp * 3.0);
  hessian[15] = -t129;
  hessian[16] = -t131;
  hessian[17] = t139;
  hessian[18] = t20;
  hessian[19] = -t127;
  hessian[20] = -t129;
  b_t24_tmp = t34 * t4;
  t42 = t33 * t2;
  t128_tmp = t34 * t6;
  t24_tmp = b_t20_tmp * t2;
  t33 *= t6;
  b_t20_tmp *= t4;
  t43 = -t96 * t97;
  hessian[21] =
      t43 *
      (((((((t17 + t19) + b_t24_tmp * 3.0) - t42 * 2.0) + t128_tmp * 3.0) -
         t24_tmp * 2.0) +
        t33) +
       b_t20_tmp);
  hessian[22] = t28;
  hessian[23] = t53;
  hessian[24] = -t128;
  hessian[25] = t140;
  hessian[26] = -t131;
  hessian[27] = t28;
  hessian[28] =
      t43 *
      (((((((t15 + t19) - b_t24_tmp * 2.0) + t42 * 3.0) + t128_tmp) + t24_tmp) +
        t33 * 3.0) -
       b_t20_tmp * 2.0);
  hessian[29] = t41;
  hessian[30] = -t130;
  hessian[31] = -t132;
  hessian[32] = t139;
  hessian[33] = t53;
  hessian[34] = t41;
  hessian[35] =
      t43 *
      (((((((t15 + t17) + b_t24_tmp) + t42) - t128_tmp * 2.0) + t24_tmp * 3.0) -
        t33 * 2.0) +
       b_t20_tmp * 3.0);
}

void PTSGradient(const double in1[3], const double in2[3], double gradient[18]) {
  double gradient_tmp;
  double t10;
  double t11;
  double t12;
  double t13;
  double t17;
  double t18;
  double t19;
  double t2;
  double t20;
  double t21;
  double t22;
  double t23;
  double t24;
  double t25;
  double t28;
  double t3;
  double t4;
  double t5;
  double t6;
  double t7;
  double t8;
  double t9;
  // PTSGradient
  //     GRADIENT = PTSGradient(IN1,IN2)
  //     This function was generated by the Symbolic Math Toolbox version 9.2.
  //     27-Jan-2023 12:44:39
  t2 = in2[0] * in1[1];
  t3 = in1[0] * in2[1];
  t4 = in2[0] * in1[2];
  t5 = in1[0] * in2[2];
  t6 = in2[1] * in1[2];
  t7 = in1[1] * in2[2];
  t8 = in2[0] * in2[0];
  t9 = in2[1] * in2[1];
  t10 = in2[2] * in2[2];
  t11 = in1[0] * in1[0];
  t12 = in1[1] * in1[1];
  t13 = in1[2] * in1[2];
  t17 = in2[0] * t11;
  t18 = in1[0] * t8;
  t19 = in2[1] * t12;
  t20 = in1[1] * t9;
  t21 = in2[2] * t13;
  t22 = in1[2] * t10;
  t23 = t2 - t3;
  t24 = t4 - t5;
  t25 = t6 - t7;
  t28 = 1.0 / std::sqrt((t8 + t9) + t10);
  t10 = 1.0 / std::sqrt((t11 + t12) + t13);
  t11 = t28 * t28 * t28;
  t12 = t10 * t10 * t10;
  gradient[0] = in1[0] * t25 * t28 * t12;
  t13 = t28 * t12;
  gradient[1] = t13 * ((t21 + in1[0] * t5) + in1[1] * t6);
  gradient_tmp = -t28 * t12;
  gradient[2] = gradient_tmp * ((t19 + in1[0] * t3) + in1[2] * t7);
  gradient[3] = in2[0] * t25 * t11 * t10;
  t8 = -t11 * t10;
  gradient[4] = t8 * ((t22 + in2[0] * t4) + in2[1] * t7);
  t9 = t11 * t10;
  gradient[5] = t9 * ((t20 + in2[0] * t2) + in2[2] * t6);
  gradient[6] = gradient_tmp * ((t21 + in1[0] * t4) + in1[1] * t7);
  gradient[7] = -in1[1] * t24 * t28 * t12;
  gradient[8] = t13 * ((t17 + in1[1] * t2) + in1[2] * t5);
  gradient[9] = t9 * ((t22 + in2[0] * t5) + in2[1] * t6);
  gradient[10] = -in2[1] * t24 * t11 * t10;
  gradient[11] = t8 * ((t18 + in2[1] * t3) + in2[2] * t4);
  gradient[12] = t13 * ((t19 + in1[0] * t2) + in1[2] * t6);
  gradient[13] = gradient_tmp * ((t17 + in1[1] * t3) + in1[2] * t4);
  gradient[14] = in1[2] * t23 * t28 * t12;
  gradient[15] = t8 * ((t20 + in2[0] * t3) + in2[2] * t7);
  gradient[16] = t9 * ((t18 + in2[1] * t2) + in2[2] * t5);
  gradient[17] = in2[2] * t23 * t11 * t10;
}

void PTSHessian(const double in1[3], const double in2[3], double hessian[108]) {
  double t10;
  double t110;
  double t111;
  double t112;
  double t113;
  double t114;
  double t115;
  double t116;
  double t117;
  double t118;
  double t12;
  double t131;
  double t132;
  double t133;
  double t14;
  double t149;
  double t150;
  double t151;
  double t152;
  double t152_tmp;
  double t153;
  double t153_tmp;
  double t154;
  double t155;
  double t157;
  double t158;
  double t159;
  double t16;
  double t172;
  double t174;
  double t175;
  double t176;
  double t177;
  double t18;
  double t2;
  double t20;
  double t206;
  double t207;
  double t208;
  double t21;
  double t217;
  double t218;
  double t219;
  double t22;
  double t220;
  double t221;
  double t222;
  double t223;
  double t224;
  double t225;
  double t226;
  double t227;
  double t228;
  double t23;
  double t24;
  double t246;
  double t25;
  double t253;
  double t254;
  double t256;
  double t257;
  double t26;
  double t260;
  double t261;
  double t262;
  double t263;
  double t264;
  double t265;
  double t27;
  double t271;
  double t272;
  double t28;
  double t29;
  double t3;
  double t30;
  double t31;
  double t35;
  double t36;
  double t37;
  double t38;
  double t39;
  double t4;
  double t40;
  double t41;
  double t42;
  double t43;
  double t44;
  double t45;
  double t46;
  double t47;
  double t48;
  double t49;
  double t5;
  double t50;
  double t51;
  double t52;
  double t54;
  double t56;
  double t58;
  double t59;
  double t6;
  double t60;
  double t61;
  double t62;
  double t63;
  double t64;
  double t7;
  double t8;
  double t83;
  double t92;
  double t93;
  double t94;
  // PTSHessian
  //     HESSIAN = PTSHessian(IN1,IN2)
  //     This function was generated by the Symbolic Math Toolbox version 9.2.
  //     27-Jan-2023 12:44:39
  t2 = in2[0] * in1[1];
  t3 = in1[0] * in2[1];
  t4 = in2[0] * in1[2];
  t5 = in1[0] * in2[2];
  t6 = in2[1] * in1[2];
  t7 = in1[1] * in2[2];
  t8 = in2[0] * in2[0];
  t10 = in2[1] * in2[1];
  t12 = in2[2] * in2[2];
  t14 = in1[0] * in1[0];
  t16 = in1[1] * in1[1];
  t18 = in1[2] * in1[2];
  t20 = in2[0] * t3;
  t21 = in2[1] * t2;
  t22 = in2[0] * t5;
  t23 = in2[2] * t4;
  t24 = in2[1] * t7;
  t25 = in2[2] * t6;
  t26 = in1[0] * t2;
  t27 = in1[0] * t4;
  t28 = in1[1] * t3;
  t29 = in1[1] * t6;
  t30 = in1[2] * t5;
  t31 = in1[2] * t7;
  t35 = in2[0] * t14;
  t36 = in1[0] * t8;
  t37 = in1[1] * t2;
  t38 = in1[0] * t3;
  t39 = in2[0] * t2;
  t40 = in2[1] * t3;
  t41 = in1[2] * t4;
  t42 = in2[1] * t16;
  t43 = in1[0] * t5;
  t44 = in2[0] * t4;
  t45 = in1[1] * t10;
  t46 = in2[2] * t5;
  t47 = in1[2] * t6;
  t48 = in1[1] * t7;
  t49 = in2[1] * t6;
  t50 = in2[2] * t7;
  t51 = in2[2] * t18;
  t52 = in1[2] * t12;
  t83 = t4 * t6;
  t92 = t2 * t4;
  t93 = t3 * t6;
  t94 = t5 * t7;
  t110 = t8 * t14;
  t111 = t2 * t2;
  t112 = t3 * t3;
  t113 = t4 * t4;
  t114 = t10 * t16;
  t115 = t5 * t5;
  t116 = t6 * t6;
  t117 = t7 * t7;
  t118 = t12 * t18;
  t152_tmp = t8 + t10;
  t152 = t152_tmp + t12;
  t153_tmp = t14 + t16;
  t153 = t153_tmp + t18;
  t54 = t21 * 3.0;
  t56 = t23 * 3.0;
  t58 = t25 * 3.0;
  t59 = t26 * 3.0;
  t60 = t27 * 3.0;
  t61 = t28 * 3.0;
  t62 = t29 * 3.0;
  t63 = t30 * 3.0;
  t64 = t31 * 3.0;
  t131 = t2 * -t3;
  t132 = t4 * -t5;
  t133 = t6 * -t7;
  t149 = t2 - t3;
  t150 = t4 - t5;
  t151 = t6 - t7;
  t272 = in2[0] * in1[0];
  t154 = t272 * t152;
  t246 = in2[1] * in1[1];
  t155 = t246 * t152;
  t157 = t272 * t153;
  t158 = t246 * t153;
  t271 = in2[2] * in1[2];
  t159 = t271 * t153;
  t172 = 1.0 / std::sqrt(t152);
  t175 = 1.0 / std::sqrt(t153);
  t153 = t172 * t172 * t172;
  t174 = t153 * t172 * t172;
  t176 = t175 * t175 * t175;
  t177 = t176 * t175 * t175;
  t152 = -(t271 * t152);
  t206 = t272 * t151 * t153 * t176;
  t207 = t246 * t150 * t153 * t176;
  t208 = t271 * t149 * t153 * t176;
  t217 = in2[1] * ((t30 + t35) + t37) * t153 * t176;
  t218 = in2[2] * ((t28 + t35) + t41) * t153 * t176;
  t219 = in1[1] * ((t23 + t36) + t40) * t153 * t176;
  t220 = in1[2] * ((t21 + t36) + t46) * t153 * t176;
  t221 = in2[0] * ((t31 + t38) + t42) * t153 * t176;
  t222 = in2[2] * ((t26 + t42) + t47) * t153 * t176;
  t223 = in1[0] * ((t25 + t39) + t45) * t153 * t176;
  t224 = in1[2] * ((t20 + t45) + t50) * t153 * t176;
  t225 = in2[0] * ((t29 + t43) + t51) * t153 * t176;
  t226 = in2[1] * ((t27 + t48) + t51) * t153 * t176;
  t227 = in1[0] * ((t24 + t44) + t52) * t153 * t176;
  t228 = in1[1] * ((t22 + t49) + t52) * t153 * t176;
  t271 = t153 * t176;
  t253 = t271 * (((in1[0] * t20 + t83) - t94) - in2[0] * t26);
  t254 = t271 * (((in1[1] * t21 + t83) - t94) - in2[1] * t28);
  t153 = -t153 * t176;
  t246 = t2 * -t7;
  t256 = t153 * (((-(in1[2] * t23) + t93) + in2[2] * t30) + t246);
  t272 = t5 * -t3;
  t257 = t153 * (((-(in1[1] * t24) + t92) + in2[1] * t29) + t272);
  t260 = t271 * (((-(in1[0] * t22) + in2[0] * t27) + t93) + t246);
  t261 = t271 * (((-(in1[2] * t25) + t92) + in2[2] * t31) + t272);
  t262 = t271 * ((((t110 + t111) + t115) + t117) + t133);
  t263 = t271 * ((((t110 + t112) + t113) + t116) + t133);
  t153 = t111 + t113;
  t264 = t271 * (((t153 + t114) + t116) + t132);
  t265 = t271 * (((t153 + t117) + t118) + t131);
  t114 = t271 * ((((t112 + t114) + t115) + t117) + t132);
  t133 = t271 * ((((t112 + t115) + t116) + t118) + t131);
  t111 = -t172 * t177;
  t113 = t111 * (((in1[1] * t59 - in1[0] * t61) - t157) + t158);
  t25 = t111 * (((in1[2] * t62 - in1[1] * t64) + t159) - t158);
  t110 = t172 * t177;
  t31 = t110 * (((in1[2] * t60 - in1[0] * t63) - t157) + t159);
  t153 = in2[2] * t174 * t175;
  t92 = t153 * (((t36 + t46) + t54) - t40 * 2.0);
  t272 = in2[1] * t174 * t175;
  t93 = t272 * (((t36 + t40) + t56) - t46 * 2.0);
  t27 = t153 * (((t45 + t50) + t20 * 3.0) - t39 * 2.0);
  t153 = in2[0] * t174 * t175;
  t30 = t153 * (((t39 + t45) + t58) - t50 * 2.0);
  t29 = t272 * (((t49 + t52) + t22 * 3.0) - t44 * 2.0);
  t176 = t153 * (((t44 + t52) + t24 * 3.0) - t49 * 2.0);
  t153 = in1[2] * t172 * t177;
  t23 = t153 * (((t35 + t41) + t61) - t37 * 2.0);
  t272 = in1[1] * t172 * t177;
  t94 = t272 * (((t35 + t37) + t63) - t41 * 2.0);
  t83 = t153 * (((t42 + t47) + t59) - t38 * 2.0);
  t26 = in1[0] * t172 * t177;
  t153 = t26 * (((t38 + t42) + t64) - t47 * 2.0);
  t28 = t272 * (((t48 + t51) + t60) - t43 * 2.0);
  t246 = t26 * (((t43 + t51) + t62) - t48 * 2.0);
  t21 = t174 * t175;
  t271 = t21 * (((in2[0] * t54 + in2[1] * t20 * -3.0) + t154) - t155);
  t272 = t21 * (((in2[0] * t56 + in2[2] * t22 * -3.0) + t154) + t152);
  t152 = t21 * (((in2[1] * t58 + in2[2] * t24 * -3.0) + t155) + t152);
  hessian[0] = t151 * t172 * t177 * ((t14 * -2.0 + t16) + t18);
  hessian[1] = -t246;
  hessian[2] = t153;
  hessian[3] = -t206;
  hessian[4] = t227;
  hessian[5] = -t223;
  hessian[6] = -t246;
  t246 = t6 * t16;
  t26 = t7 * t18;
  hessian[7] =
      t111 * ((((in1[1] * t43 * 3.0 + t246 * 2.0) - t6 * t18) + t26 * 3.0) +
              in1[0] * in1[2] * -t3);
  hessian[8] = t25;
  hessian[9] = -t225;
  hessian[10] = t261;
  hessian[11] = t263;
  hessian[12] = t153;
  hessian[13] = t25;
  hessian[14] =
      t110 * ((((in1[2] * t38 * 3.0 + t246 * 3.0) + t26 * 2.0) + t16 * -t7) +
              in1[0] * in1[1] * -t5);
  hessian[15] = t221;
  hessian[16] = -t262;
  hessian[17] = t257;
  hessian[18] = -t206;
  hessian[19] = -t225;
  hessian[20] = t221;
  hessian[21] = t151 * t174 * t175 * ((t8 * -2.0 + t10) + t12);
  hessian[22] = t176;
  hessian[23] = -t30;
  hessian[24] = t227;
  hessian[25] = t261;
  hessian[26] = -t262;
  hessian[27] = t176;
  t246 = in2[1] * t44;
  t26 = t7 * t10;
  t153 = t6 * t12;
  hessian[28] =
      t21 *
      ((((-in2[2] * t39 + t246 * 3.0) + t26 * 2.0) + t153 * 3.0) + t12 * -t7);
  hessian[29] = -t152;
  hessian[30] = -t223;
  hessian[31] = t263;
  hessian[32] = t257;
  hessian[33] = -t30;
  hessian[34] = -t152;
  t152 = -t174 * t175;
  hessian[35] = t152 * ((((in2[2] * t39 * 3.0 - t246) - t6 * t10) + t26 * 3.0) +
                        t153 * 2.0);
  t246 = t4 * t14;
  t26 = t5 * t18;
  hessian[36] =
      t110 * ((((-in1[2] * t37 + t246 * 2.0) + t5 * t16 * 3.0) - t4 * t18) +
              t26 * 3.0);
  hessian[37] = t28;
  hessian[38] = t31;
  hessian[39] = t256;
  hessian[40] = t226;
  hessian[41] = -t264;
  hessian[42] = t28;
  hessian[43] = -t150 * t172 * t177 * ((t14 - t16 * 2.0) + t18);
  hessian[44] = -t94;
  hessian[45] = -t228;
  hessian[46] = t207;
  hessian[47] = t219;
  hessian[48] = t31;
  hessian[49] = -t94;
  hessian[50] =
      t111 * ((((in1[2] * t37 * 3.0 + t246 * 3.0) + t26 * 2.0) + t14 * -t5) +
              t16 * -t5);
  hessian[51] = t114;
  hessian[52] = -t217;
  hessian[53] = t260;
  hessian[54] = t256;
  hessian[55] = -t228;
  hessian[56] = t114;
  t246 = t5 * t8;
  t26 = t4 * t10;
  t153 = t4 * t12;
  hessian[57] = t152 * ((((t246 * 2.0 + t26 * 3.0) + t153 * 3.0) + t12 * -t5) +
                        in2[1] * in2[2] * -t3);
  hessian[58] = -t29;
  hessian[59] = t272;
  hessian[60] = t226;
  hessian[61] = t207;
  hessian[62] = -t217;
  hessian[63] = -t29;
  hessian[64] = -t150 * t174 * t175 * ((t8 - t10 * 2.0) + t12);
  hessian[65] = t93;
  hessian[66] = -t264;
  hessian[67] = t219;
  hessian[68] = t260;
  hessian[69] = t272;
  hessian[70] = t93;
  hessian[71] = t21 * ((((in2[2] * t40 * 3.0 - t4 * t8) + t246 * 3.0) - t26) +
                       t153 * 2.0);
  t246 = t2 * t14;
  t26 = t3 * t16;
  t153 = t2 * t18;
  hessian[72] =
      t111 * ((((t246 * 2.0 - t2 * t16) + t26 * 3.0) - t153) + t3 * t18 * 3.0);
  hessian[73] = t113;
  hessian[74] = -t83;
  hessian[75] = -t254;
  hessian[76] = t265;
  hessian[77] = -t222;
  hessian[78] = t113;
  hessian[79] = t110 * ((((t246 * 3.0 + t26 * 2.0) + t153 * 3.0) + t14 * -t3) +
                        t18 * -t3);
  hessian[80] = t23;
  hessian[81] = -t133;
  hessian[82] = t253;
  hessian[83] = t218;
  hessian[84] = -t83;
  hessian[85] = t23;
  hessian[86] = t149 * t172 * t177 * (t153_tmp - t18 * 2.0);
  hessian[87] = t224;
  hessian[88] = -t220;
  hessian[89] = -t208;
  hessian[90] = -t254;
  hessian[91] = -t133;
  hessian[92] = t224;
  t246 = t3 * t8;
  t26 = t2 * t10;
  t153 = t2 * t12;
  hessian[93] =
      t21 * ((((t246 * 2.0 + t26 * 3.0) + t153 * 3.0) + t10 * -t3) + t12 * -t3);
  hessian[94] = -t271;
  hessian[95] = t27;
  hessian[96] = t265;
  hessian[97] = t253;
  hessian[98] = -t220;
  hessian[99] = -t271;
  hessian[100] =
      t152 * ((((-t2 * t8 + t246 * 3.0) + t26 * 2.0) - t153) + t3 * t12 * 3.0);
  hessian[101] = -t92;
  hessian[102] = -t222;
  hessian[103] = t218;
  hessian[104] = -t208;
  hessian[105] = t27;
  hessian[106] = -t92;
  hessian[107] = t149 * t174 * t175 * (t152_tmp - t12 * 2.0);
}

AffineDecomposedTreeTrunk::AffineDecomposedTreeTrunk(const json& config) : AffineDecomposedObject(new ReducedTreeTrunk(config["proxy"]), config) {
	_tree_trunk = dynamic_cast<ReducedTreeTrunk*>(_proxy);
}

void AffineDecomposedTreeTrunk::CalculateRigidRotationInfos(const CalculateLevel& level, const Ref<const VectorXd>& x, std::vector<Matrix3d>& rotations, std::vector<MatrixXd>& rotation_gradient, std::vector<MatrixXd>& rotation_hessian) const {
	const VectorXd x_tree_trunk = _tree_trunk->_base * x + _tree_trunk->_shift;
	const int num_points = x_tree_trunk.size() / 3;
	
	Vector3d e_prev = x_tree_trunk.segment<3>(0) - _tree_trunk->_x_root;
	Vector3d e_next = x_tree_trunk.segment<3>(3) - x_tree_trunk.segment<3>(0);
	Vector3d t_prev = e_prev.normalized();
	Vector3d t_next = e_next.normalized();

	Matrix3d cur_rotation = Matrix3d::Identity();
	MatrixXd cur_rotation_gradient = MatrixXd::Zero(9, 9);
	MatrixXd cur_rotation_hessian = MatrixXd::Zero(9, 81);

	Matrix<double, 9, 6> pepq;
	pepq.leftCols(3) = _tree_trunk->_base.middleRows(0, 3).transpose();
	pepq.rightCols(3) = (_tree_trunk->_base.middleRows(3, 3) - _tree_trunk->_base.middleRows(0, 3)).transpose();

	int num_children_processed = 0;
	const double t_delta = 1.0 / (num_points - 1);
	double t_current = t_delta; // end of current segment
	for (int i = 0, i3 = 0; i < num_points - 1; i++, i3 += 3, t_current += t_delta) {
		const double C = t_prev.dot(t_next);
		const Vector3d S = t_prev.cross(t_next);
		const Matrix3d R = C * Matrix3d::Identity() + 1 / (1 + C) * S * S.transpose() + HatMatrix(S);

		Vector6d pCpe;
		Matrix<double, 6, 3> pSpe;
		PTCGradient(e_prev.data(), e_next.data(), pCpe.data());
		PTSGradient(e_prev.data(), e_next.data(), pSpe.data());
		Vector9d pCpq = pepq * pCpe;
		Matrix<double, 9, 3> pSpq = pepq * pSpe;

		Matrix6d p2Cpe2;
		Matrix<double, 6, 18> p2Spe2;
		PTCHessian(e_prev.data(), e_next.data(), p2Cpe2.data());
		PTSHessian(e_prev.data(), e_next.data(), p2Spe2.data());
		Matrix9d p2Cpq2 = pepq * p2Cpe2 * pepq.transpose();
		Matrix<double, 9, 27> p2Spq2 = pepq * p2Spe2 * Eigen::kroneckerProduct(Matrix3d::Identity(), pepq.transpose());
		
		Vector9d pRpq[3][3];
		Matrix9d p2Rpq2[3][3];

		const double denominator = 1 + C;
		for (int j = 0, j9 = 0; j < 3; j++, j9 += 9) {
			const double Sj = S(j);
			const auto& pSjpq = pSpq.col(j);
			const auto& p2Sjpq2 = p2Spq2.middleCols(j9, 9);
			pRpq[j][j] = pCpq + 2 * Sj / denominator * pSjpq - Sj * Sj / (denominator * denominator) * pCpq;
			p2Rpq2[j][j] = 2 * Sj / denominator * p2Sjpq2 + (1 - Sj * Sj / (denominator * denominator)) * p2Cpq2
						 + 2 / denominator * pSjpq * pSjpq.transpose()
						 - 2 * Sj / (denominator * denominator) * (pSjpq * pCpq.transpose() + pCpq * pSjpq.transpose())
						 + 2 * Sj * Sj / (denominator * denominator * denominator) * pCpq * pCpq.transpose();
			for (int k = 0, k9 = 0; k < 3; k++, k9 += 9) {
				if (k == j) {
					continue;
				}
				const double Sk = S(k);
				const auto& pSkpq = pSpq.col(k);
				const auto& p2Skpq2 = p2Spq2.middleCols(k9, 9);
				
				pRpq[j][k] = Sj / denominator * pSkpq + Sk / denominator * pSjpq - Sj * Sk / (denominator * denominator) * pCpq;
				p2Rpq2[j][k] = 1 / denominator * (pSjpq * pSkpq.transpose() + pSkpq * pSjpq.transpose())
							 - Sj / (denominator * denominator) * (pSkpq * pCpq.transpose() + pCpq * pSkpq.transpose())
							 - Sk / (denominator * denominator) * (pSjpq * pCpq.transpose() + pCpq * pSjpq.transpose())
							 + 2 * Sj * Sk / (denominator * denominator * denominator) * pCpq * pCpq.transpose()
							 + Sj / denominator * p2Skpq2 + Sk / denominator * p2Sjpq2
							 - Sj * Sk / (denominator * denominator) * p2Cpq2;
			}
		}

		// TODO: add skew matrix part

		pRpq[0][1] -= pSpq.col(2);
		pRpq[1][0] += pSpq.col(2);
		pRpq[0][2] += pSpq.col(1);
		pRpq[2][0] -= pSpq.col(1);
		pRpq[1][2] -= pSpq.col(0);
		pRpq[2][1] += pSpq.col(0);

		p2Rpq2[0][1] -= p2Spq2.middleCols(18, 9);
		p2Rpq2[1][0] += p2Spq2.middleCols(18, 9);
		p2Rpq2[0][2] += p2Spq2.middleCols(9, 9);
		p2Rpq2[2][0] -= p2Spq2.middleCols(9, 9);
		p2Rpq2[1][2] -= p2Spq2.middleCols(0, 9);
		p2Rpq2[2][1] += p2Spq2.middleCols(0, 9);

		// induction
		
		MatrixXd next_rotation_gradient;
		next_rotation_gradient.resizeLike(cur_rotation_gradient);

		MatrixXd next_rotation_hessian;
		next_rotation_hessian.resizeLike(cur_rotation_hessian);

		const auto& getIndex = [](int i, int j) -> int {
			return 3 * j + i;
		};

		for (int j = 0; j < 3; j++) {
			for (int k = 0; k < 3; k++) {
				Ref<MatrixXd> pjkpq = next_rotation_gradient.col(getIndex(j, k));
				pjkpq.setZero();
				for (int l = 0; l < 3; l++) {
					pjkpq += pRpq[j][l] * cur_rotation(l, k) + R(j, l) * cur_rotation_gradient.col(getIndex(l, k));
				}
			}
		}

		for (int j = 0; j < 3; j++) {
			for (int k = 0; k < 3; k++) {
				Ref<MatrixXd> p2jkpq2 = next_rotation_hessian.middleCols(9 * getIndex(j, k), 9);
				p2jkpq2.setZero();
				for (int l = 0; l < 3; l++) {
					p2jkpq2 += p2Rpq2[j][l] * cur_rotation(l, k)
							 + 2 * pRpq[j][l] * cur_rotation_gradient.col(getIndex(l, k)).transpose()
							 + R(j, l) * cur_rotation_hessian.middleCols(9 * getIndex(l, k), 9);
				}
			}
		}

		cur_rotation = R * cur_rotation;
		cur_rotation_gradient = next_rotation_gradient;
		cur_rotation_hessian = next_rotation_hessian;
		
		while(num_children_processed < _num_children && _children_position[num_children_processed] <= t_current) {
			switch (level) {
				case AffineDecomposedObject::CalculateLevel::kHessian:
					rotation_hessian.push_back(cur_rotation_hessian);
				case AffineDecomposedObject::CalculateLevel::kGradient:
					rotation_gradient.push_back(cur_rotation_gradient);
				case AffineDecomposedObject::CalculateLevel::kValue:
					rotations.push_back(cur_rotation);
			}
			num_children_processed++;
		}

		e_prev = e_next;
		t_prev = t_next;
		e_next = x_tree_trunk.segment<3>(i3 + 6) - x_tree_trunk.segment<3>(i3 + 3);
		t_next = e_next.normalized();

		pepq.leftCols(3) = pepq.rightCols(3);
		pepq.rightCols(3) = (_tree_trunk->_base.middleRows(i3 + 6, 3) - _tree_trunk->_base.middleRows(i3 + 3, 3)).transpose();
	}
}